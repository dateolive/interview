<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java集合高频面试题 | 面试向的个人学习汇总</title>
    <meta name="generator" content="VuePress 1.8.0">
    <link rel="icon" href="/interview/img/favicon.ico">
    <script data-ad-client="ca-pub-7828333725993554" async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <meta name="description" content="主要记录个人对源码级的阅读笔记和面试向问题的记录">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/interview/assets/css/0.styles.6c53556f.css" as="style"><link rel="preload" href="/interview/assets/js/app.80049718.js" as="script"><link rel="preload" href="/interview/assets/js/2.1b653881.js" as="script"><link rel="preload" href="/interview/assets/js/7.e19bca31.js" as="script"><link rel="prefetch" href="/interview/assets/js/10.4196677e.js"><link rel="prefetch" href="/interview/assets/js/11.e68fe268.js"><link rel="prefetch" href="/interview/assets/js/12.f8d07b57.js"><link rel="prefetch" href="/interview/assets/js/13.07ac9907.js"><link rel="prefetch" href="/interview/assets/js/14.8f9a59bc.js"><link rel="prefetch" href="/interview/assets/js/15.fcc6ad3a.js"><link rel="prefetch" href="/interview/assets/js/16.0f26fde2.js"><link rel="prefetch" href="/interview/assets/js/17.44035c68.js"><link rel="prefetch" href="/interview/assets/js/18.08ed95bf.js"><link rel="prefetch" href="/interview/assets/js/19.c8008721.js"><link rel="prefetch" href="/interview/assets/js/20.89f4ba3f.js"><link rel="prefetch" href="/interview/assets/js/21.93c430c3.js"><link rel="prefetch" href="/interview/assets/js/22.db8d2249.js"><link rel="prefetch" href="/interview/assets/js/23.497d4632.js"><link rel="prefetch" href="/interview/assets/js/24.90014ecb.js"><link rel="prefetch" href="/interview/assets/js/25.f9f1f1fa.js"><link rel="prefetch" href="/interview/assets/js/26.e0894144.js"><link rel="prefetch" href="/interview/assets/js/27.71834393.js"><link rel="prefetch" href="/interview/assets/js/28.18ca29d4.js"><link rel="prefetch" href="/interview/assets/js/29.56877793.js"><link rel="prefetch" href="/interview/assets/js/3.0af6d715.js"><link rel="prefetch" href="/interview/assets/js/30.5bbfb720.js"><link rel="prefetch" href="/interview/assets/js/31.64b3fa52.js"><link rel="prefetch" href="/interview/assets/js/32.df8d8d5a.js"><link rel="prefetch" href="/interview/assets/js/33.b93bbeff.js"><link rel="prefetch" href="/interview/assets/js/34.9ac14150.js"><link rel="prefetch" href="/interview/assets/js/35.4eb42f99.js"><link rel="prefetch" href="/interview/assets/js/36.7cf89034.js"><link rel="prefetch" href="/interview/assets/js/37.2c0f337c.js"><link rel="prefetch" href="/interview/assets/js/38.1386b512.js"><link rel="prefetch" href="/interview/assets/js/39.400b2ed4.js"><link rel="prefetch" href="/interview/assets/js/4.2ef604b3.js"><link rel="prefetch" href="/interview/assets/js/40.603ba506.js"><link rel="prefetch" href="/interview/assets/js/41.ccad2a89.js"><link rel="prefetch" href="/interview/assets/js/42.e04e7b92.js"><link rel="prefetch" href="/interview/assets/js/43.0e0ae4d9.js"><link rel="prefetch" href="/interview/assets/js/44.8f0c160e.js"><link rel="prefetch" href="/interview/assets/js/45.6d258493.js"><link rel="prefetch" href="/interview/assets/js/46.de9ce0a4.js"><link rel="prefetch" href="/interview/assets/js/5.68faddf1.js"><link rel="prefetch" href="/interview/assets/js/6.0725d888.js"><link rel="prefetch" href="/interview/assets/js/8.c9e7bbee.js"><link rel="prefetch" href="/interview/assets/js/9.5725c3f8.js">
    <link rel="stylesheet" href="/interview/assets/css/0.styles.6c53556f.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/interview/" class="home-link router-link-active"><img src="/interview/img/study.png" alt="面试向的个人学习汇总" class="logo"> <span class="site-name can-hide">面试向的个人学习汇总</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="语言" class="dropdown-title"><a href="/interview/code/" class="link-title">语言</a> <span class="title" style="display:none;">语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/interview/pages/6824ac/" class="nav-link">Java</a></li><li class="dropdown-item"><!----> <a href="/interview/pages/28591f/" class="nav-link">C/C++</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><a href="/interview/database/" class="link-title">数据库</a> <span class="title" style="display:none;">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/interview/pages/5bf967/" class="nav-link">MySQL</a></li><li class="dropdown-item"><!----> <a href="/interview/pages/b9a12d/" class="nav-link">Redis</a></li><li class="dropdown-item"><!----> <a href="/interview/pages/c4ff75/" class="nav-link">MongoDB</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="学科" class="dropdown-title"><a href="/interview/base/" class="link-title">学科</a> <span class="title" style="display:none;">学科</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/interview/pages/ff28d3/" class="nav-link">操作系统</a></li><li class="dropdown-item"><!----> <a href="/interview/pages/2ea435/" class="nav-link">计算机网络</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="框架" class="dropdown-title"><a href="/interview/frame/" class="link-title">框架</a> <span class="title" style="display:none;">框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/interview/pages/5c591f/" class="nav-link">spring全家桶</a></li><li class="dropdown-item"><h4>权限框架</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/interview/pages/2622ac/" class="nav-link">Shiro</a></li><li class="dropdown-subitem"><a href="/interview/pages/d8fc22/" class="nav-link">SpringSecurity</a></li></ul></li><li class="dropdown-item"><!----> <a href="/interview/pages/79b4b1/" class="nav-link">Mybatis</a></li><li class="dropdown-item"><!----> <a href="/interview/pages/f635df/" class="nav-link">中间件</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="算法|数据结构" class="dropdown-title"><a href="/interview/algorithm/" class="link-title">算法|数据结构</a> <span class="title" style="display:none;">算法|数据结构</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/interview/pages/817a23/" class="nav-link">算法</a></li><li class="dropdown-item"><!----> <a href="/interview/pages/cf8bda/" class="nav-link">数据结构</a></li><li class="dropdown-item"><!----> <a href="/interview/pages/cf8bda/" class="nav-link">LeetCode</a></li><li class="dropdown-item"><!----> <a href="/interview/pages/cf8bda/" class="nav-link">剑指offer</a></li><li class="dropdown-item"><!----> <a href="/interview/pages/cf8bda/" class="nav-link">其他算法题</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其他" class="dropdown-title"><a href="/interview/other/" class="link-title">其他</a> <span class="title" style="display:none;">其他</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/interview/pages/b40d7a/" class="nav-link">设计模式</a></li><li class="dropdown-item"><!----> <a href="/interview/pages/bafb3a/" class="nav-link">Git相关</a></li><li class="dropdown-item"><!----> <a href="/interview/pages/c259fd/" class="nav-link">Docker</a></li><li class="dropdown-item"><!----> <a href="/interview/pages/2d6562/" class="nav-link">智力题</a></li><li class="dropdown-item"><!----> <a href="/interview/pages/84648d/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/interview/pages/e2e2c9/" class="nav-link">其他</a></li></ul></div></div> <a href="https://github.com/mdy-mystudy/interview/" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="语言" class="dropdown-title"><a href="/interview/code/" class="link-title">语言</a> <span class="title" style="display:none;">语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/interview/pages/6824ac/" class="nav-link">Java</a></li><li class="dropdown-item"><!----> <a href="/interview/pages/28591f/" class="nav-link">C/C++</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><a href="/interview/database/" class="link-title">数据库</a> <span class="title" style="display:none;">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/interview/pages/5bf967/" class="nav-link">MySQL</a></li><li class="dropdown-item"><!----> <a href="/interview/pages/b9a12d/" class="nav-link">Redis</a></li><li class="dropdown-item"><!----> <a href="/interview/pages/c4ff75/" class="nav-link">MongoDB</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="学科" class="dropdown-title"><a href="/interview/base/" class="link-title">学科</a> <span class="title" style="display:none;">学科</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/interview/pages/ff28d3/" class="nav-link">操作系统</a></li><li class="dropdown-item"><!----> <a href="/interview/pages/2ea435/" class="nav-link">计算机网络</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="框架" class="dropdown-title"><a href="/interview/frame/" class="link-title">框架</a> <span class="title" style="display:none;">框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/interview/pages/5c591f/" class="nav-link">spring全家桶</a></li><li class="dropdown-item"><h4>权限框架</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/interview/pages/2622ac/" class="nav-link">Shiro</a></li><li class="dropdown-subitem"><a href="/interview/pages/d8fc22/" class="nav-link">SpringSecurity</a></li></ul></li><li class="dropdown-item"><!----> <a href="/interview/pages/79b4b1/" class="nav-link">Mybatis</a></li><li class="dropdown-item"><!----> <a href="/interview/pages/f635df/" class="nav-link">中间件</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="算法|数据结构" class="dropdown-title"><a href="/interview/algorithm/" class="link-title">算法|数据结构</a> <span class="title" style="display:none;">算法|数据结构</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/interview/pages/817a23/" class="nav-link">算法</a></li><li class="dropdown-item"><!----> <a href="/interview/pages/cf8bda/" class="nav-link">数据结构</a></li><li class="dropdown-item"><!----> <a href="/interview/pages/cf8bda/" class="nav-link">LeetCode</a></li><li class="dropdown-item"><!----> <a href="/interview/pages/cf8bda/" class="nav-link">剑指offer</a></li><li class="dropdown-item"><!----> <a href="/interview/pages/cf8bda/" class="nav-link">其他算法题</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其他" class="dropdown-title"><a href="/interview/other/" class="link-title">其他</a> <span class="title" style="display:none;">其他</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/interview/pages/b40d7a/" class="nav-link">设计模式</a></li><li class="dropdown-item"><!----> <a href="/interview/pages/bafb3a/" class="nav-link">Git相关</a></li><li class="dropdown-item"><!----> <a href="/interview/pages/c259fd/" class="nav-link">Docker</a></li><li class="dropdown-item"><!----> <a href="/interview/pages/2d6562/" class="nav-link">智力题</a></li><li class="dropdown-item"><!----> <a href="/interview/pages/84648d/" class="nav-link">Linux</a></li><li class="dropdown-item"><!----> <a href="/interview/pages/e2e2c9/" class="nav-link">其他</a></li></ul></div></div> <a href="https://github.com/mdy-mystudy/interview/" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JAVA</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Java基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>Java集合</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/interview/pages/9fb2bc/" aria-current="page" class="active sidebar-link">Java集合高频面试题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview/pages/9fb2bc/#java常见集合面试题" class="sidebar-link">Java常见集合面试题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview/pages/9fb2bc/#_1-java常见的集合有哪些" class="sidebar-link">1.Java常见的集合有哪些？</a></li><li class="sidebar-sub-header"><a href="/interview/pages/9fb2bc/#_2-线程安全的集合有哪些-线程不安全的呢" class="sidebar-link">2.线程安全的集合有哪些？线程不安全的呢？</a></li><li class="sidebar-sub-header"><a href="/interview/pages/9fb2bc/#_3-arraylist和linkedlist有什么异同" class="sidebar-link">3.ArrayList和LinkedList有什么异同？</a></li><li class="sidebar-sub-header"><a href="/interview/pages/9fb2bc/#_4-arraylist和vector的区别" class="sidebar-link">4.ArrayList和Vector的区别？</a></li><li class="sidebar-sub-header"><a href="/interview/pages/9fb2bc/#_5-说一下arraylist的扩容机制" class="sidebar-link">5.说一下ArrayList的扩容机制？</a></li><li class="sidebar-sub-header"><a href="/interview/pages/9fb2bc/#_6-system-arraycopy和arrays-copyof有什么区别和联系" class="sidebar-link">6.System.arraycopy和Arrays.copyOf有什么区别和联系？</a></li><li class="sidebar-sub-header"><a href="/interview/pages/9fb2bc/#_7-array和arraylist有什么区别-什么时候应该用array而不是arraylist" class="sidebar-link">7.Array和ArrayList有什么区别？什么时候应该用Array而不是ArrayList？</a></li><li class="sidebar-sub-header"><a href="/interview/pages/9fb2bc/#_8-hashmap的底层数据结构是什么" class="sidebar-link">8.HashMap的底层数据结构是什么？</a></li><li class="sidebar-sub-header"><a href="/interview/pages/9fb2bc/#_9-解决hash冲突有哪些-hashmap用的哪种" class="sidebar-link">9.解决hash冲突有哪些？hashmap用的哪种？</a></li><li class="sidebar-sub-header"><a href="/interview/pages/9fb2bc/#_10-为什么在解决hash冲突时-不直接使用红黑树-而选择先用链表然后再转红黑树" class="sidebar-link">10.为什么在解决hash冲突时，不直接使用红黑树，而选择先用链表然后再转红黑树？</a></li><li class="sidebar-sub-header"><a href="/interview/pages/9fb2bc/#_11-hashmap的默认负载因子为什么是0-75-而不能是0-6或者0-8" class="sidebar-link">11.hashmap的默认负载因子为什么是0.75，而不能是0.6或者0.8？</a></li><li class="sidebar-sub-header"><a href="/interview/pages/9fb2bc/#_12-hashmap中key的存储索引是如何计算出来的" class="sidebar-link">12.hashmap中key的存储索引是如何计算出来的？</a></li><li class="sidebar-sub-header"><a href="/interview/pages/9fb2bc/#_13-hashmap的put流程" class="sidebar-link">13.hashmap的put流程？</a></li><li class="sidebar-sub-header"><a href="/interview/pages/9fb2bc/#_14-hashmap的扩容方式" class="sidebar-link">14.hashmap的扩容方式？</a></li><li class="sidebar-sub-header"><a href="/interview/pages/9fb2bc/#_15-一般使用什么作为hashmap的key" class="sidebar-link">15.一般使用什么作为hashmap的key？</a></li><li class="sidebar-sub-header"><a href="/interview/pages/9fb2bc/#_16-为什么说hashmap线程不安全" class="sidebar-link">16.为什么说hashmap线程不安全？</a></li><li class="sidebar-sub-header"><a href="/interview/pages/9fb2bc/#_17-concurrenthashmap的实现原理是什么" class="sidebar-link">17.ConcurrentHashMap的实现原理是什么？</a></li><li class="sidebar-sub-header"><a href="/interview/pages/9fb2bc/#_18-concurrenthashmap的put执行逻辑" class="sidebar-link">18.ConcurrentHashMap的put执行逻辑？</a></li><li class="sidebar-sub-header"><a href="/interview/pages/9fb2bc/#_19-concurrenthashmap的get方法是否要加锁-为什么" class="sidebar-link">19.ConcurrentHashMap的get方法是否要加锁，为什么？</a></li><li class="sidebar-sub-header"><a href="/interview/pages/9fb2bc/#_20-get方法不需要加锁是与被volatile修饰的哈希桶有关吗" class="sidebar-link">20.get方法不需要加锁是与被volatile修饰的哈希桶有关吗？</a></li><li class="sidebar-sub-header"><a href="/interview/pages/9fb2bc/#_21-concurrenthashmap不支持-key或value为null的原因" class="sidebar-link">21.ConcurrentHashMap不支持 key或value为null的原因？</a></li><li class="sidebar-sub-header"><a href="/interview/pages/9fb2bc/#_22-concurrenthashmap的并发度是多少" class="sidebar-link">22.ConcurrentHashMap的并发度是多少？</a></li><li class="sidebar-sub-header"><a href="/interview/pages/9fb2bc/#_23-concurrenthashmap-迭代器是强一致性还是弱一致性" class="sidebar-link">23.ConcurrentHashMap 迭代器是强一致性还是弱一致性？</a></li><li class="sidebar-sub-header"><a href="/interview/pages/9fb2bc/#_24-说一说jdk1-7和jdk1-8中concurrenthashmap的区别" class="sidebar-link">24.说一说JDK1.7和JDK1.8中ConcurrentHashMap的区别？</a></li><li class="sidebar-sub-header"><a href="/interview/pages/9fb2bc/#_25-concurrenthashmap-和hashtable的效率哪个更高-为什么" class="sidebar-link">25.ConcurrentHashMap 和Hashtable的效率哪个更高？为什么？</a></li><li class="sidebar-sub-header"><a href="/interview/pages/9fb2bc/#_26-说一下hashtable的锁机制" class="sidebar-link">26.说一下HashTable的锁机制？</a></li><li class="sidebar-sub-header"><a href="/interview/pages/9fb2bc/#_27-多线程下安全的操作-map还有其他方法吗" class="sidebar-link">27.多线程下安全的操作 map还有其他方法吗？</a></li><li class="sidebar-sub-header"><a href="/interview/pages/9fb2bc/#_28-hashset和hashmap的区别" class="sidebar-link">28. HashSet和HashMap的区别？</a></li><li class="sidebar-sub-header"><a href="/interview/pages/9fb2bc/#_29-collection框架中实现比较要怎么做" class="sidebar-link">29.Collection框架中实现比较要怎么做？</a></li><li class="sidebar-sub-header"><a href="/interview/pages/9fb2bc/#_30-iterator-和-listiterator-有什么区别" class="sidebar-link">30.Iterator 和 ListIterator 有什么区别？</a></li><li class="sidebar-sub-header"><a href="/interview/pages/9fb2bc/#_31-讲一讲快速失败-fail-fast-和安全失败-fail-safe" class="sidebar-link">31.讲一讲快速失败(fail-fast)和安全失败(fail-safe)</a></li></ul></li></ul></li><li><a href="/interview/pages/5bde17/" class="sidebar-link">hashmap</a></li><li><a href="/interview/pages/ee3f6d/" class="sidebar-link">concurrenthashmap</a></li><li><a href="/interview/pages/31ac8b/" class="sidebar-link">linkedlist</a></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Java并发</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>JVM</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>新特性</span> <span class="arrow right"></span></p> <!----></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>c++</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-1cd794fe><div class="articleInfo" data-v-1cd794fe><ul class="breadcrumbs" data-v-1cd794fe><li data-v-1cd794fe><a href="/interview/" title="首页" class="iconfont icon-home router-link-active" data-v-1cd794fe></a></li> <li data-v-1cd794fe><a href="/interview/categories/?category=JAVA%26C%2B%2B" title="分类" data-v-1cd794fe>JAVA&amp;C++</a></li> <li data-v-1cd794fe><a href="/interview/categories/?category=JAVA" title="分类" data-v-1cd794fe>JAVA</a></li> <li data-v-1cd794fe><a href="/interview/categories/?category=Java%E9%9B%86%E5%90%88" title="分类" data-v-1cd794fe>Java集合</a></li></ul> <div class="info" data-v-1cd794fe><div title="作者" class="author iconfont icon-touxiang" data-v-1cd794fe><a href="https://github.com/dateolive" target="_blank" title="作者" class="beLink" data-v-1cd794fe>梦独吟</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-1cd794fe><a href="javascript:;" data-v-1cd794fe>2021-09-09</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">
          Java集合高频面试题
        </h1> <!----> <div class="theme-vdoing-content content__default"><h2 id="java常见集合面试题"><a href="#java常见集合面试题" class="header-anchor">#</a> Java常见集合面试题</h2> <h3 id="_1-java常见的集合有哪些"><a href="#_1-java常见的集合有哪些" class="header-anchor">#</a> 1.Java常见的集合有哪些？</h3> <p>Java集合类主要由两个根接口Collection和Map派生出来的，Collection派生出三个子接口：List，Set，Queue，因此Java集合大致也可分为List，Set，Queue，Map四种接口体系。</p> <p><strong>注意：Collection是一个接口，Collections是一个工具类，Map不是Collection的子接口</strong>。</p> <p><img src="https://gitee.com/zhangrenfeng/images/raw/master/img/20210909205240.png" alt="11"></p> <p><img src="https://gitee.com/zhangrenfeng/images/raw/master/img/20210909205301.png" alt="12"></p> <p>图中，List代表了有序可重复集合，可直接根据元素的索引来访问；Set代表无序不可重复集合，只能根据元素本身来访问；Queue是队列集合。</p> <p>Map代表的是存储key-value对的集合，可根据元素的key来访问value。</p> <p>上图中淡绿色背景覆盖的是集合体系中常用的实现类，分别是ArrayList、LinkedList、ArrayQueue、HashSet、TreeSet、HashMap、TreeMap等实现类。</p> <h3 id="_2-线程安全的集合有哪些-线程不安全的呢"><a href="#_2-线程安全的集合有哪些-线程不安全的呢" class="header-anchor">#</a> 2.线程安全的集合有哪些？线程不安全的呢？</h3> <p>线程安全的：</p> <ul><li>hashtable：比hashmap多了个线程安全</li> <li>concurrenthashmap：是一种高效且线程安全的集合</li> <li>vector：比ArrayList多个了同步化机制</li> <li>stack：栈，也是线程安全的，继承于vector</li></ul> <p>线程不安全的：</p> <ul><li>HashMap</li> <li>LinkedList</li> <li>ArrayList</li> <li>HashSet</li> <li>TreeMap</li> <li>TreeSet</li></ul> <h3 id="_3-arraylist和linkedlist有什么异同"><a href="#_3-arraylist和linkedlist有什么异同" class="header-anchor">#</a> 3.ArrayList和LinkedList有什么异同？</h3> <ul><li><p>是否保证线程安全： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</p></li> <li><p>底层数据结构： Arraylist 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。）</p></li> <li><p>插入和删除是否受元素位置的影响：
ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。
LinkedList 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（add(E e)、addFirst(E e)、addLast(E e)、removeFirst() 、 removeLast()），近似 O(1)，如果是要在指定位置 i 插入和删除元素的话（add(int index, E element)，remove(Object o)） 时间复杂度近似为 O(n) ，因为需要先移动到指定位置再插入。</p></li> <li><p>是否支持快速随机访问： LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。</p></li> <li><p>内存空间占用： ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p></li></ul> <h3 id="_4-arraylist和vector的区别"><a href="#_4-arraylist和vector的区别" class="header-anchor">#</a> 4.ArrayList和Vector的区别？</h3> <p>ArrayList是List的主要实现类，底层使用<code>Object[]</code>存储，适用于频繁的查找工作，线程不安全。</p> <p>Vector是List的古老实现类，底层使用<code>Object[]</code>存储，线程安全的。</p> <p>ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍，这样ArrayList就有利于节约内存空间。</p> <h3 id="_5-说一下arraylist的扩容机制"><a href="#_5-说一下arraylist的扩容机制" class="header-anchor">#</a> 5.说一下ArrayList的扩容机制？</h3> <p>ArrayList扩容的本质就是计算出新的扩容数组的size后实例化，并将原有数组内容复制到新数组中去。<strong>默认情况下，新的容量会是原容量的1.5倍。</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//判断是否可以容纳e，若能，则直接添加在末尾；若不能，则进行扩容，然后再把e添加在末尾</span>
    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Increments modCount!!</span>
    <span class="token comment">//将e添加到数组末尾</span>
    elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token comment">// 每次在add()一个元素时，arraylist都需要对这个list的容量进行一个判断。通过ensureCapacityInternal()方法确保当前ArrayList维护的数组具有存储新元素的能力，经过处理之后将元素存储在数组elementData的尾部</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token function">calculateCapacity</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">calculateCapacity</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">,</span> <span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//如果传入的是个空数组则最小容量取默认容量与minCapacity之间的最大值</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>DEFAULT_CAPACITY<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> minCapacity<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        modCount<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token comment">// 若ArrayList已有的存储能力满足最低存储要求，则返回add直接添加元素；如果最低要求的存储能力&gt;ArrayList已有的存储能力，这就表示ArrayList的存储能力不足，因此需要调用 grow();方法进行扩容</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 获取elementData数组的内存空间长度</span>
        <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token comment">// 扩容至原来的1.5倍</span>
        <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//校验容量是否够</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>
        <span class="token comment">//若预设值大于默认的最大值，检查是否溢出</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 调用Arrays.copyOf方法将elementData数组指向新的内存空间</span>
         <span class="token comment">//并将elementData的数据复制到新的内存空间</span>
        elementData <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br></div></div><h3 id="_6-system-arraycopy和arrays-copyof有什么区别和联系"><a href="#_6-system-arraycopy和arrays-copyof有什么区别和联系" class="header-anchor">#</a> 6.System.arraycopy和Arrays.copyOf有什么区别和联系？</h3> <p>联系：</p> <p>看两者源代码可以发现 copyOf()内部实际调用了 System.arraycopy() 方法</p> <p>区别：</p> <ul><li><p>arraycopy() 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置。</p></li> <li><p>copyOf() 是系统自动在内部新建一个数组，并返回该数组。</p></li></ul> <h3 id="_7-array和arraylist有什么区别-什么时候应该用array而不是arraylist"><a href="#_7-array和arraylist有什么区别-什么时候应该用array而不是arraylist" class="header-anchor">#</a> 7.Array和ArrayList有什么区别？什么时候应该用Array而不是ArrayList？</h3> <ul><li><p>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。</p></li> <li><p>Array 大小是固定的，ArrayList 的大小是动态变化的。</p></li> <li><p>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator() 等等。</p></li></ul> <h3 id="_8-hashmap的底层数据结构是什么"><a href="#_8-hashmap的底层数据结构是什么" class="header-anchor">#</a> 8.HashMap的底层数据结构是什么？</h3> <p>在JDK1.7和JDK1.8有些区别。</p> <p>在JDK1.7中，是由数组和链表组成，数组是hashmap的主体，引入链表主要是为了解决哈希冲突。</p> <p>在JDK1.8中，由数组+链表+红黑树组成，当链表长度过长时，会严重影响hashmap的性能，因为链表的搜索时间复杂度为On，而引入红黑树就是为了解决这个问题，红黑树的搜索时间复杂度为Ologn。</p> <p>当链表长度大于8，数组大小超过64就会转化为红黑树。</p> <p>如果数组大小长度小于64，那么会先进行数组扩容，而不是转化为红黑树，以减少时间。</p> <p><img src="https://gitee.com/zhangrenfeng/images/raw/master/img/20210909213813.png" alt="12"></p> <h3 id="_9-解决hash冲突有哪些-hashmap用的哪种"><a href="#_9-解决hash冲突有哪些-hashmap用的哪种" class="header-anchor">#</a> 9.解决hash冲突有哪些？hashmap用的哪种？</h3> <p>解决hash冲突的方法有：开放定址法，链地址法（拉链法），再哈希法，建立公共溢出区。hashmap使用的是链地址法。</p> <ul><li>开放定址法也称为<code>再散列法</code>，基本思想就是，如果<code>p=H(key)</code>出现冲突时，则以<code>p</code>为基础，再次hash，<code>p1=H(p)</code>,如果p1再次出现冲突，则以p1为基础，以此类推，直到找到一个不冲突的哈希地址<code>pi</code>。 因此开放定址法所需要的hash表的长度要大于等于所需要存放的元素，而且因为存在再次hash，所以<code>只能在删除的节点上做标记，而不能真正删除节点。</code></li> <li>再哈希法(双重散列，多重散列)，提供多个不同的hash函数，当<code>R1=H1(key1)</code>发生冲突时，再计算<code>R2=H2(key1)</code>，直到没有冲突为止。 这样做虽然不易产生堆集，但增加了计算的时间。</li> <li>链地址法(拉链法)，将哈希值相同的元素构成一个同义词的单链表,并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。</li> <li>建立公共溢出区，将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。</li></ul> <h3 id="_10-为什么在解决hash冲突时-不直接使用红黑树-而选择先用链表然后再转红黑树"><a href="#_10-为什么在解决hash冲突时-不直接使用红黑树-而选择先用链表然后再转红黑树" class="header-anchor">#</a> 10.为什么在解决hash冲突时，不直接使用红黑树，而选择先用链表然后再转红黑树？</h3> <p>因为红黑树需要左旋，右旋，变色这些操作来保证平衡，而单链表不需要。当元素小于8个的时候，此时做查询操作，链表结构已经能够保证性能了。当元素大于8个的时候，红黑树的搜索复杂度为ologn ，而链表是on，所以需要转化为红黑树来加快查询性能，但是新增节点的效率就变慢了。</p> <p>因此，如果一开始使用红黑树结构，元素太少，新增效率又太低，无疑是浪费性能。</p> <h3 id="_11-hashmap的默认负载因子为什么是0-75-而不能是0-6或者0-8"><a href="#_11-hashmap的默认负载因子为什么是0-75-而不能是0-6或者0-8" class="header-anchor">#</a> 11.hashmap的默认负载因子为什么是0.75，而不能是0.6或者0.8？</h3> <p>回答这个问题前，我们来先看下HashMap的默认构造函数：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>     <span class="token keyword">int</span> threshold<span class="token punctuation">;</span>             <span class="token comment">// 容纳键值对的最大值</span>
     <span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span>    <span class="token comment">// 负载因子</span>
     <span class="token keyword">int</span> modCount<span class="token punctuation">;</span>  
     <span class="token keyword">int</span> size<span class="token punctuation">;</span>  
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳键值对的最大值。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</p> <p>默认的loadFactor是0.75，0.75是对空间和时间效率的一个平衡选择，一般不要修改，除非在时间和空间比较特殊的情况下 ：</p> <ul><li><p>如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值 。</p></li> <li><p>相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</p></li></ul> <p>我们来追溯下作者在源码中的注释（JDK1.7）：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">As</span> a general rule<span class="token punctuation">,</span> the <span class="token keyword">default</span> load factor <span class="token punctuation">(</span><span class="token number">.75</span><span class="token punctuation">)</span> offers a good tradeoff between time and space <span class="token class-name"><span class="token namespace">costs<span class="token punctuation">.</span></span> Higher</span> values decrease the space overhead but increase the lookup cost <span class="token punctuation">(</span>reflected in most of the operations of the <span class="token class-name">HashMap</span> <span class="token keyword">class</span><span class="token punctuation">,</span> including get and put<span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token class-name">The</span> expected number of entries in the map and its load factor should be taken into account when setting its initial capacity<span class="token punctuation">,</span> so as <span class="token keyword">to</span> <span class="token namespace">minimize</span> the number of rehash <span class="token class-name"><span class="token namespace">operations<span class="token punctuation">.</span></span> If</span> the initial capacity is greater than the maximum number of entries divided by the load factor<span class="token punctuation">,</span> no rehash operations will ever occur<span class="token punctuation">.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>翻译过来大概的意思是：作为一般规则，默认负载因子（0.75）在时间和空间成本上提供了很好的折衷。较高的值会降低空间开销，但提高查找成本（体现在大多数的HashMap类的操作，包括get和put）。设置初始大小时，应该考虑预计的entry数在map及其负载系数，并且尽量减少rehash操作的次数。如果初始容量大于最大条目数除以负载因子，rehash操作将不会发生。</p> <p>对于想对hashmap深入理解的，可以看这篇文章
<a href="https://blog.csdn.net/wangxuelei036/article/details/106134115" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/wangxuelei036/article/details/106134115<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="_12-hashmap中key的存储索引是如何计算出来的"><a href="#_12-hashmap中key的存储索引是如何计算出来的" class="header-anchor">#</a> 12.hashmap中key的存储索引是如何计算出来的？</h3> <p>首先根据key的值计算出hashcode的值，然后根据hashcode计算出hash值，最后通过hash&amp;（length-1）计算得到存储的位置。看看源码的实现：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// jdk1.7</span>
方法一：
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> h <span class="token operator">=</span> hashSeed<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">!=</span> h <span class="token operator">&amp;&amp;</span> k <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>Hashing</span><span class="token punctuation">.</span><span class="token function">stringHash32</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

    h <span class="token operator">^=</span> k<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 为第一步：取hashCode值</span>
    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
方法二：
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">//jdk1.7的源码，jdk1.8没有这个方法，但实现原理一样</span>
     <span class="token keyword">return</span> h <span class="token operator">&amp;</span> <span class="token punctuation">(</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//第三步：取模运算</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// jdk1.8</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>   
     <span class="token keyword">int</span> h<span class="token punctuation">;</span>
     <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* 
     h = key.hashCode() 为第一步：取hashCode值
     h ^ (h &gt;&gt;&gt; 16)  为第二步：高位参与运算
    */</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p> <p><img src="https://gitee.com/zhangrenfeng/images/raw/master/img/20210909223431.png" alt="12"></p> <h3 id="_13-hashmap的put流程"><a href="#_13-hashmap的put流程" class="header-anchor">#</a> 13.hashmap的put流程？</h3> <p>简要流程如下：</p> <ol><li><p>首先根据 key 的值计算 hash 值，找到该元素在数组中存储的下标；</p></li> <li><p>如果数组是空的，则调用 resize 进行初始化；</p></li> <li><p>如果没有哈希冲突直接放在对应的数组下标里；</p></li> <li><p>如果冲突了，且 key 已经存在，就覆盖掉 value；</p></li> <li><p>如果冲突后，发现该节点是红黑树，就将这个节点挂在树上；</p></li> <li><p>如果冲突后是链表，判断该链表是否大于 8 ，如果大于 8 并且数组容量小于 64，就进行扩容；如果链表节点大于 8 并且数组的容量大于 64，则将这个结构转换为红黑树；否则，链表插入键值对，若 key 存在，就覆盖掉 value。</p></li></ol> <p><img src="https://gitee.com/zhangrenfeng/images/raw/master/img/20210909223853.png" alt="22"></p> <h3 id="_14-hashmap的扩容方式"><a href="#_14-hashmap的扩容方式" class="header-anchor">#</a> 14.hashmap的扩容方式？</h3> <p>扩容（resize），JDK1.8中 集合是由数组+链表+红黑树构成，向 HashMap 中插入元素时，如果HashMap 集合的元素已经大于了最大承载容量threshold（capacity * loadFactor），这里的threshold不是数组的最大长度。那么必须扩大数组的长度，Java中数组是无法自动扩容的，我们采用的方法是用一个更大的数组代替这个小的数组</p> <p>JDK1.7中扩容先创建一个新的大容量数组，然后依次重新计算原集合所有元素的索引(rehash一次)，然后重新赋值。如果数组某个位置发生了hash冲突，使用的是单链表的头插入方法，同一位置的新元素总是放在链表的头部，这样与原集合链表对比，扩容之后的可能就是倒序的链表了。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>
    <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>
    <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            threshold <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>
            <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 没超过最大值，就扩充为原来的2倍</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> oldCap <span class="token operator">&gt;=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>
            newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// double threshold</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// initial capacity was placed in threshold</span>
        newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// signifies using defaults</span>
        newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>
        newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 计算新的resize上限</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>
        newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">&quot;rawtypes&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>
    table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 把每个bucket都移动到新的buckets中</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                    newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
                    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> loHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> loTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> hiHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> hiTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>
                    <span class="token keyword">do</span> <span class="token punctuation">{</span>
                        next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                        <span class="token comment">// 原索引</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                                loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            <span class="token keyword">else</span>
                                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                        <span class="token comment">// 原索引+oldCap</span>
                        <span class="token keyword">else</span> <span class="token punctuation">{</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                                hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            <span class="token keyword">else</span>
                                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token comment">// 原索引放到bucket里</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                        newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token comment">// 原索引+oldCap放到bucket里</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                        newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> newTab<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br></div></div><p>相比于JDK1.7，1.8使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。</p> <h3 id="_15-一般使用什么作为hashmap的key"><a href="#_15-一般使用什么作为hashmap的key" class="header-anchor">#</a> 15.一般使用什么作为hashmap的key？</h3> <p>一般用Integer、String 这种不可变类当 HashMap 当 key，而且 String 最为常用。</p> <ul><li>因为字符串是不可变的，所以在它创建的时候 hashcode 就被缓存了，不需要重新计算。这就是 HashMap 中的键往往都使用字符串的原因。</li> <li>因为获取对象的时候要用到 equals() 和 hashCode() 方法，那么键对象正确的重写这两个方法是非常重要的,这些类已经很规范的重写了 hashCode() 以及 equals() 方法。</li></ul> <h3 id="_16-为什么说hashmap线程不安全"><a href="#_16-为什么说hashmap线程不安全" class="header-anchor">#</a> 16.为什么说hashmap线程不安全？</h3> <ul><li>多线程下扩容死循环。JDK1.7中的 HashMap 使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。因此，JDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。</li> <li>多线程的put可能导致元素的丢失。多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。此问题在JDK 1.7和 JDK 1.8 中都存在。</li> <li>put和get并发时，可能导致get为null。线程1执行put时，因为元素个数超出threshold而导致rehash，线程2此时执行get，有可能导致这个问题。此问题在JDK 1.7和 JDK 1.8 中都存在。</li></ul> <p>详细可以看下这篇文章<a href="https://blog.csdn.net/swpu_ocean/article/details/88917958" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/swpu_ocean/article/details/88917958<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="_17-concurrenthashmap的实现原理是什么"><a href="#_17-concurrenthashmap的实现原理是什么" class="header-anchor">#</a> 17.ConcurrentHashMap的实现原理是什么？</h3> <p>ConcurrentHashMap  在 JDK1.7 和 JDK1.8  的实现方式是不同的。</p> <p><strong>先来看下JDK1.7</strong></p> <p>JDK1.7中的ConcurrentHashMap  是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成，即ConcurrentHashMap 把哈希桶切分成小数组（Segment ），每个小数组有 n 个 HashEntry 组成。</p> <p>其中，Segment 继承了 ReentrantLock，所以 Segment 是一种可重入锁，扮演锁的角色；HashEntry 用于存储键值对数据。</p> <p><img src="https://gitee.com/zhangrenfeng/images/raw/master/img/20210909233607.png" alt="12"></p> <p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问，能够实现真正的并发访问。</p> <p><strong>再来看下JDK1.8</strong></p> <p>在数据结构上， JDK1.8  中的ConcurrentHashMap  选择了与 HashMap 相同的<strong>数组+链表+红黑树</strong>结构；在锁的实现上，抛弃了原有的 Segment 分段锁，采用<code>CAS + synchronized</code>实现更加低粒度的锁。</p> <p>将锁的级别控制在了更细粒度的哈希桶元素级别，也就是说只需要锁住这个链表头结点（红黑树的根节点），就不会影响其他的哈希桶元素的读写，大大提高了并发度。</p> <p><img src="https://gitee.com/zhangrenfeng/images/raw/master/img/20210909233705.png" alt="111"></p> <h3 id="_18-concurrenthashmap的put执行逻辑"><a href="#_18-concurrenthashmap的put执行逻辑" class="header-anchor">#</a> 18.ConcurrentHashMap的put执行逻辑？</h3> <p>在JDK1.7中：</p> <p>首先，会先尝试获取锁，如果获取失败，则利用自旋获取锁，如果自选超过64次，则改为阻塞获取锁。</p> <p>获取到锁后：</p> <ol><li>将当前的Segment中的table通过key的hashcode定位到HashEntry</li> <li>遍历该HashEntry，如果不为空则判断传入的key和当前遍历的key是否相等，相等则进行覆盖。</li> <li>不为空则需要新建一个HashEntry并加入到Segment中，同时会先判断是否需要扩容。</li> <li>释放Segment的锁。</li></ol> <p>在JDK1.8中：</p> <ol><li>根据 key 计算出 hash值。</li> <li>判断是否需要进行初始化。</li> <li>定位到 Node，拿到首节点 f，判断首节点 f：
<ul><li>如果为  null  ，则通过cas的方式尝试添加。</li> <li>如果为 <code>f.hash = MOVED = -1</code> ，说明其他线程在扩容，参与一起扩容。</li> <li>如果都不满足 ，synchronized 锁住 f 节点，判断是链表还是红黑树，遍历插入。</li></ul></li> <li>当在链表长度达到8的时候，数组扩容或者将链表转换为红黑树。</li></ol> <h3 id="_19-concurrenthashmap的get方法是否要加锁-为什么"><a href="#_19-concurrenthashmap的get方法是否要加锁-为什么" class="header-anchor">#</a> 19.ConcurrentHashMap的get方法是否要加锁，为什么？</h3> <p>get方法不需要加锁，因为Node元素的<code>val</code>和<code>next</code>指针，都是用volatile修饰的，在多线程情况下线程A修改新增节点，对于线程B是可见的。</p> <p>这也是它比其他并发集合比如hashtable，用 Collections.synchronizedMap()包装的 HashMap 安全效率高的原因之一。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span>
    <span class="token comment">//可以看到这些都用了volatile修饰</span>
    <span class="token keyword">volatile</span> <span class="token class-name">V</span> val<span class="token punctuation">;</span>
    <span class="token keyword">volatile</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="_20-get方法不需要加锁是与被volatile修饰的哈希桶有关吗"><a href="#_20-get方法不需要加锁是与被volatile修饰的哈希桶有关吗" class="header-anchor">#</a> 20.get方法不需要加锁是与被volatile修饰的哈希桶有关吗？</h3> <p>无关。哈希桶table用volatile修饰主要是保证数组扩容时的可见性。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Segment</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">ReentrantLock</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>

    <span class="token comment">// 存放数据的桶</span>
    <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">HashEntry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="_21-concurrenthashmap不支持-key或value为null的原因"><a href="#_21-concurrenthashmap不支持-key或value为null的原因" class="header-anchor">#</a> 21.ConcurrentHashMap不支持 key或value为null的原因？</h3> <p>value不能为null的原因，在多线程情况下，如果<code>map.get(key)</code>为null，会无法判断，是映射的value为null还是value的值为null，这样就产生了二义性。</p> <p>而单线程的hashmap却可以利用<code>containsKey(key)</code>去判断是否包含了这个null</p> <p>至于key为什么不能为空，等找找资料查查看。</p> <h3 id="_22-concurrenthashmap的并发度是多少"><a href="#_22-concurrenthashmap的并发度是多少" class="header-anchor">#</a> 22.ConcurrentHashMap的并发度是多少？</h3> <p>在JDK1.7中，并发度默认是16，这个值可以在构造函数中设置。如果自己设置了并发度，ConcurrentHashMap 会使用大于等于该值的最小的2的幂指数作为实际并发度，也就是比如你设置的值是17，那么实际并发度是32。</p> <h3 id="_23-concurrenthashmap-迭代器是强一致性还是弱一致性"><a href="#_23-concurrenthashmap-迭代器是强一致性还是弱一致性" class="header-anchor">#</a> 23.ConcurrentHashMap 迭代器是强一致性还是弱一致性？</h3> <p>与HashMap迭代器的强一致性不同，ConcurrentHashMap的迭代器是弱一致性。</p> <p>ConcurrentHashMap 的迭代器创建后，就会按照哈希表结构遍历每个元素，但在遍历过程中，内部元素可能会发生变化，如果变化发生在已遍历过的部分，迭代器就不会反映出来，而如果变化发生在未遍历过的部分，迭代器就会发现并反映出来，这就是弱一致性。</p> <p>这样迭代器线程可以使用原来老的数据，而写线程也可以并发的完成改变，更重要的，这保证了多个线程并发执行的连续性和扩展性，是性能提升的关键。</p> <h3 id="_24-说一说jdk1-7和jdk1-8中concurrenthashmap的区别"><a href="#_24-说一说jdk1-7和jdk1-8中concurrenthashmap的区别" class="header-anchor">#</a> 24.说一说JDK1.7和JDK1.8中ConcurrentHashMap的区别？</h3> <ul><li>数据结构：取消了Segment分段锁数据结构，使用了数组+链表+红黑树。</li> <li>保证线程安全机制：JDK1.7采用了Segment的分段锁机制实现线程安全，其中Segment继承Reentrantlock。JDK1.8才用CAS和synchronized保证线程安全。</li> <li>锁的粒度：原来是对需要进行数据操作的Segment加锁，现在调整为对每个数组的元素加锁（Node）.</li> <li>链表转化为红黑树：定位结点的hash算法简化会带来弊端,Hash冲突加剧,因此在链表节点数量大于8时，会将链表转化为红黑树进行存储。</li> <li>查询时间复杂度：从原来的遍历链表On变成遍历红黑树的Ologn</li></ul> <h3 id="_25-concurrenthashmap-和hashtable的效率哪个更高-为什么"><a href="#_25-concurrenthashmap-和hashtable的效率哪个更高-为什么" class="header-anchor">#</a> 25.ConcurrentHashMap 和Hashtable的效率哪个更高？为什么？</h3> <p>ConcurrentHashMap的效率更高，因为Hashtable是给整个哈希表加了一把大锁实现线程安全，而ConcurrentHashMap的锁粒度更低，在JDK1.7使用Segment分段锁实现线程安全，在JDK1.8中采用CAS和synchronized实现。</p> <h3 id="_26-说一下hashtable的锁机制"><a href="#_26-说一下hashtable的锁机制" class="header-anchor">#</a> 26.说一下HashTable的锁机制？</h3> <p>Hashtable是使用Synchronized来实现线程安全的，给整个哈希表加了一把大锁，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞等待需要的锁被释放，在竞争激烈的多线程场景中性能就会非常差！</p> <p><img src="https://gitee.com/zhangrenfeng/images/raw/master/img/20210910111202.png" alt="111"></p> <h3 id="_27-多线程下安全的操作-map还有其他方法吗"><a href="#_27-多线程下安全的操作-map还有其他方法吗" class="header-anchor">#</a> 27.多线程下安全的操作 map还有其他方法吗？</h3> <p>还可以使用<code>Collections.synchronizedMap</code>方法，对方法进行加同步锁</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizedMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span>
        <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">1978198479659022715L</span><span class="token punctuation">;</span>

        <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> m<span class="token punctuation">;</span>     <span class="token comment">// Backing Map</span>
        <span class="token keyword">final</span> <span class="token class-name">Object</span>      mutex<span class="token punctuation">;</span>        <span class="token comment">// Object on which to synchronize</span>

        <span class="token class-name">SynchronizedMap</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>m <span class="token operator">=</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span>requireNon <span class="token keyword">null</span> <span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
            mutex <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token class-name">SynchronizedMap</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> m<span class="token punctuation">,</span> <span class="token class-name">Object</span> mutex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>m <span class="token operator">=</span> m<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>mutex <span class="token operator">=</span> mutex<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token comment">// 省略部分代码</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>如果传入的是 HashMap 对象，其实也是对 HashMap 做的方法做了一层包装，里面使用对象锁来保证多线程场景下，线程安全，本质也是对 HashMap 进行全表锁。<strong>在竞争激烈的多线程环境下性能依然也非常差，不推荐使用！</strong></p> <h3 id="_28-hashset和hashmap的区别"><a href="#_28-hashset和hashmap的区别" class="header-anchor">#</a> 28. HashSet和HashMap的区别？</h3> <p><img src="https://gitee.com/zhangrenfeng/images/raw/master/img/20210910111432.png" alt="22"></p> <p>补充HashSet的实现：HashSet的底层其实就是HashMap，只不过我们<strong>HashSet是实现了Set接口并且把数据作为K值，而V值一直使用一个相同的虚值来保存</strong>。如源码所示：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> PRESENT<span class="token punctuation">)</span><span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>由于HashMap的K值本身就不允许重复，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V，那么在HashSet中执行这一句话始终会返回一个false，导致插入失败，这样就保证了数据的不可重复性。</p> <h3 id="_29-collection框架中实现比较要怎么做"><a href="#_29-collection框架中实现比较要怎么做" class="header-anchor">#</a> 29.Collection框架中实现比较要怎么做？</h3> <p>第一种，实体类实现Comparable接口，并实现 compareTo(T t) 方法，称为内部比较器。</p> <p>第二种，创建一个外部比较器，这个外部比较器要实现Comparator接口的 compare(T t1, T t2)方法。</p> <h3 id="_30-iterator-和-listiterator-有什么区别"><a href="#_30-iterator-和-listiterator-有什么区别" class="header-anchor">#</a> 30.Iterator 和 ListIterator 有什么区别？</h3> <ul><li>遍历。使用Iterator，可以遍历所有集合，如Map，List，Set；但只能在向前方向上遍历集合中的元素。</li></ul> <p>使用ListIterator，只能遍历List实现的对象，但可以向前和向后遍历集合中的元素。</p> <ul><li><p>添加元素。Iterator无法向集合中添加元素；而，ListIteror可以向集合添加元素。</p></li> <li><p>修改元素。Iterator无法修改集合中的元素；而，ListIterator可以使用set()修改集合中的元素。</p></li> <li><p>索引。Iterator无法获取集合中元素的索引；而，使用ListIterator，可以获取集合中元素的索引。</p></li></ul> <h3 id="_31-讲一讲快速失败-fail-fast-和安全失败-fail-safe"><a href="#_31-讲一讲快速失败-fail-fast-和安全失败-fail-safe" class="header-anchor">#</a> 31.讲一讲快速失败(fail-fast)和安全失败(fail-safe)</h3> <p><strong>快速失败（fail—fast）</strong></p> <ul><li><p>在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。</p></li> <li><p>原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个        modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p></li> <li><p>注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。</p></li> <li><p>场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改），比如HashMap、ArrayList 这些集合类。</p></li></ul> <p><strong>安全失败（fail—safe）</strong></p> <ul><li><p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p></li> <li><p>原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</p></li> <li><p>缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p></li> <li><p>场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改，比如：ConcurrentHashMap。</p></li></ul></div></div> <!----> <div class="page-edit"><div class="edit-link"><a href="https://github.com/mdy-mystudy/interview/edit/master/docs/01.JAVA&amp;C++/01.JAVA/02.Java集合/1.Java集合高频面试题.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2021/09/10, 11:27:20</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/interview/pages/a13c39/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">java基础下</div></a> <a href="/interview/pages/5bde17/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">hashmap</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/interview/pages/a13c39/" class="prev">java基础下</a></span> <span class="next"><a href="/interview/pages/5bde17/">hashmap</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><!----> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2021-2021
    <span>梦独吟</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/interview/assets/js/app.80049718.js" defer></script><script src="/interview/assets/js/2.1b653881.js" defer></script><script src="/interview/assets/js/7.e19bca31.js" defer></script>
  </body>
</html>
