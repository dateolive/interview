(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{466:function(_,v,t){"use strict";t.r(v);var a=t(27),s=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"体系结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#体系结构"}},[_._v("#")]),_._v(" 体系结构")]),_._v(" "),t("p",[t("img",{attrs:{src:"/interview/img/105765468a802.jpeg",alt:"11"}})]),_._v(" "),t("h3",{attrs:{id:"计算机网络体系可以大致分为一下三种-osi七层模型、tcp-ip四层模型和五层模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#计算机网络体系可以大致分为一下三种-osi七层模型、tcp-ip四层模型和五层模型"}},[_._v("#")]),_._v(" 计算机网络体系可以大致分为一下三种，OSI七层模型、TCP/IP四层模型和五层模型")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/zhangrenfeng/images/raw/master/img/20210914215054.png",alt:"12"}})]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/zhangrenfeng/images/raw/master/img/20210914215115.png",alt:"13"}})]),_._v(" "),t("h3",{attrs:{id:"网络协议三要素"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#网络协议三要素"}},[_._v("#")]),_._v(" 网络协议三要素")]),_._v(" "),t("ul",[t("li",[_._v("语法：即数据与控制信息的结构或格式。")]),_._v(" "),t("li",[_._v("语义：即需要发出何种控制信息，完成何种动作以及做出何种响应。")]),_._v(" "),t("li",[_._v("同步：即事件实现顺序的详细说明。")])]),_._v(" "),t("h3",{attrs:{id:"协议和服务的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#协议和服务的区别"}},[_._v("#")]),_._v(" 协议和服务的区别")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/zhangrenfeng/images/raw/master/img/20210914215334.png",alt:"13"}})]),_._v(" "),t("h2",{attrs:{id:"物理层和数据链路层"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#物理层和数据链路层"}},[_._v("#")]),_._v(" 物理层和数据链路层")]),_._v(" "),t("h3",{attrs:{id:"_1-三种通讯方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-三种通讯方式"}},[_._v("#")]),_._v(" 1.三种通讯方式")]),_._v(" "),t("p",[_._v("通信的三种方式：单工，半双工，双工。")]),_._v(" "),t("h3",{attrs:{id:"_2-物理层的作用是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-物理层的作用是什么"}},[_._v("#")]),_._v(" 2.物理层的作用是什么？")]),_._v(" "),t("p",[_._v("透明传输比特流")]),_._v(" "),t("h3",{attrs:{id:"_3-物理层几大特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-物理层几大特性"}},[_._v("#")]),_._v(" 3.物理层几大特性")]),_._v(" "),t("p",[_._v("（1）机械特性：指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等。")]),_._v(" "),t("p",[_._v("（2）电气特性：指明在接口电缆的各条线上出现的电压的范围。")]),_._v(" "),t("p",[_._v("（3）功能特性，指明某条线上出现的某一电平的电压的意义。")]),_._v(" "),t("p",[_._v("（4）过程特性：指明对于不同功能的各种可能事件的出现顺序")]),_._v(" "),t("h3",{attrs:{id:"_4-信道复用技术"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-信道复用技术"}},[_._v("#")]),_._v(" 4.信道复用技术")]),_._v(" "),t("p",[_._v("频分复用、时分复用、统计时分复用、波分复用和码分复用")]),_._v(" "),t("h3",{attrs:{id:"_5-数据链路层的三个基本问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-数据链路层的三个基本问题"}},[_._v("#")]),_._v(" 5.数据链路层的三个基本问题")]),_._v(" "),t("p",[_._v("封装成帧，透明传输，差错检测")]),_._v(" "),t("h3",{attrs:{id:"_6-以太网交换机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-以太网交换机"}},[_._v("#")]),_._v(" 6.以太网交换机")]),_._v(" "),t("p",[_._v("以太网交换机根据mac地址来转发数据。")]),_._v(" "),t("h3",{attrs:{id:"_7-交换机和集线器区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-交换机和集线器区别"}},[_._v("#")]),_._v(" 7.交换机和集线器区别")]),_._v(" "),t("p",[_._v("交换机宽带共享，而集线器是独占的")]),_._v(" "),t("h3",{attrs:{id:"_8-数据链路层的作用是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-数据链路层的作用是什么"}},[_._v("#")]),_._v(" 8.数据链路层的作用是什么？")]),_._v(" "),t("p",[_._v("链路管理、封装成帧；透明传输；流量控制、差错检测、寻址等")]),_._v(" "),t("h2",{attrs:{id:"网络层-ip-icmp-arp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#网络层-ip-icmp-arp"}},[_._v("#")]),_._v(" 网络层（IP,ICMP,ARP）")]),_._v(" "),t("h3",{attrs:{id:"_1-arp协议和arp攻击"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-arp协议和arp攻击"}},[_._v("#")]),_._v(" 1.ARP协议和ARP攻击")]),_._v(" "),t("p",[_._v("ARP协议完成了IP地址和MAC地址的映射，每个主机都设有一个ARP高速缓存，里面有所在局域网上的各主机和路由器的IP地址和MAC地址的映射表。当源主机要发送数据包到目的主机时，会先检查自己的ARP高速缓存，如果有，就直接将数据包发送到这个MAC地址，如果没有，就向所在的局域网发起一个ARP请求的广播包（在自己发送ARP请求广播包时，还会带上自己的IP地址和MAC地址的映射），收到请求的主机，首先会检查自己的IP地址和目的主机的IP是否一致，如果一致，则先保存源主机地址和MAC地址的映射到自己的ARP缓存，然后发送ARP响应数据包。源主机收到响应数据包后，先添加目的主机和MAC地址的映射到ARP缓存中，再进行数据传输，如果源主机一直没有收到响应，表示ARP查询失败。")]),_._v(" "),t("p",[_._v("如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。")]),_._v(" "),t("p",[_._v("ARP攻击就是伪造ARP应答的IP地址和MAC地址。")]),_._v(" "),t("h3",{attrs:{id:"_2-icmp协议是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-icmp协议是什么"}},[_._v("#")]),_._v(" 2.ICMP协议是什么？")]),_._v(" "),t("p",[_._v("ICMP协议简介ICMP是“Internet Control Message Protocol”（Internet控制消息协议）的缩写。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。")]),_._v(" "),t("p",[_._v("我们常用的 ping 程序，使用的就是查询类型的 ICMP 报文，它是一种主动请求，并且获得主动应答的 ICMP 协议。")]),_._v(" "),t("h3",{attrs:{id:"_3-路由器和交换机的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-路由器和交换机的区别"}},[_._v("#")]),_._v(" 3.路由器和交换机的区别")]),_._v(" "),t("ol",[t("li",[_._v("工作层次不同，交换机工作再数据链路层，而路由器工作在网络层。")]),_._v(" "),t("li",[_._v("数据转发所依据的对象不同，交换机根据MAC地址，而路由器根据IP地址转发。")]),_._v(" "),t("li",[_._v("传统交换机只能分隔冲突域，不能分隔广播域。而路由器可以分隔广播域。")])]),_._v(" "),t("h3",{attrs:{id:"_4-ip地址分类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-ip地址分类"}},[_._v("#")]),_._v(" 4.IP地址分类")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/zhangrenfeng/images/raw/master/img/20210915172912.png",alt:"222"}})]),_._v(" "),t("h3",{attrs:{id:"_5-dhcp协议是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-dhcp协议是什么"}},[_._v("#")]),_._v(" 5.DHCP协议是什么？")]),_._v(" "),t("p",[_._v("DHCP租约过程就是DHCP客户机动态获取IP地址的过程。")]),_._v(" "),t("p",[_._v("DHCP租约过程分为4步：")]),_._v(" "),t("ul",[t("li",[_._v("客户机请求IP（客户机发DHCPDISCOVER广播包）；")]),_._v(" "),t("li",[_._v("服务器响应（服务器发DHCPOFFER广播包）；")]),_._v(" "),t("li",[_._v("客户机选择IP（客户机发DHCPREQUEST广播包）；")]),_._v(" "),t("li",[_._v("服务器确定租约（服务器发DHCPACK/DHCPNAK广播包）")])]),_._v(" "),t("h3",{attrs:{id:"_6-ipv4和ipv6的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-ipv4和ipv6的区别"}},[_._v("#")]),_._v(" 6.IPV4和IPV6的区别")]),_._v(" "),t("p",[t("a",{attrs:{href:"https://www.cnblogs.com/98pyh/p/11953241.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("https://www.cnblogs.com/98pyh/p/11953241.html"),t("OutboundLink")],1)]),_._v(" "),t("h2",{attrs:{id:"传输层-tcp-udp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#传输层-tcp-udp"}},[_._v("#")]),_._v(" 传输层（TCP,UDP）")]),_._v(" "),t("h3",{attrs:{id:"_1-tcp的三次握手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-tcp的三次握手"}},[_._v("#")]),_._v(" 1.TCP的三次握手？")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/zhangrenfeng/images/raw/master/img/20210915174228.png",alt:"11"}})]),_._v(" "),t("p",[_._v("三次握手机制：")]),_._v(" "),t("ul",[t("li",[_._v("第一次握手，客户端请求建立连接，向服务端发送一个同步报文（SYN=1）,同时选择一个随机数seq=x作为初始序列号，并进入SYN_SENT状态，等待服务器确认。")]),_._v(" "),t("li",[_._v("第二次握手，服务端收到连接请求报文后，如果同意建立连接，则向客户端发送同步确认报文（SYN=1,ACK=1），确认号为ack=x+1，同时选择一个随机数seq=y作为初始序列号，此时服务器进入SYN_RECV状态。")]),_._v(" "),t("li",[_._v("第三次握手，客户端收到服务端的确认后，向服务端发送一个确认报文（ACK=1），确认号为ack=y+1，序列号为seq=x+1，客户端和服务器都进入到ESTABLISHED状态，完成三次握手。")])]),_._v(" "),t("p",[_._v("在理想的情况下，TCP一旦建立连接后，在通信双方中的任何一方主动关闭连接之前，TCP连接都将一直保持下去。")]),_._v(" "),t("h3",{attrs:{id:"_2-为什么需要三次握手-而不是两次"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-为什么需要三次握手-而不是两次"}},[_._v("#")]),_._v(" 2.为什么需要三次握手，而不是两次？")]),_._v(" "),t("p",[_._v("主要有三个原因：")]),_._v(" "),t("ol",[t("li",[_._v("防止已过期的连接请求报文又突然传送到服务器，因而产生错误和资源浪费。")])]),_._v(" "),t("p",[_._v("在双方两次握手即可建立连接的情况下，假设客户端发送了A报文段请求建立连接，由于网络原因造成A暂时无法到达服务器，服务端接收不到请求报文就不会返回确认报文。")]),_._v(" "),t("p",[_._v("客户端长时间得不到应答报文后，会重新发送请求报文B，此时请求报文B顺利到达服务端，服务器随即返回确认报文并进入ESTABLISHED状态，客户端接收到应答报文后也进入ESTABLISHED状态，双方建立连接并传输数据，之后正常断开连接。")]),_._v(" "),t("p",[_._v("而这个时候A请求报文才到达服务端，服务器随即返回确认报文并进入 ESTABLISHED 状态，但是已经进入 CLOSED 状态的客户端无法再接受确认报文段，更无法进入 ESTABLISHED 状态，这将导致服务器长时间单方面等待，造成资源浪费。")]),_._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[_._v("三次握手才能让自己和对方确认发送和接收能力都正常。")])]),_._v(" "),t("ul",[t("li",[_._v("第一次握手：客户端只是发送请求报文，什么都无法确认，而服务端可以确认自己的接收能力和对方的发送能力都正常。")]),_._v(" "),t("li",[_._v("第二次握手：客户端可以确认自己的发送能力和接收能力正常，对方的发送能力和接收能了正常。")]),_._v(" "),t("li",[_._v("第三次握手：服务端可以确认自己的发送能力和接收能力正常，对方的发送能力和接收能了正常。")])]),_._v(" "),t("p",[_._v("可见，三次握手才能让双方都确认自己和对方的发送能力和接收能力都正常。")]),_._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[_._v("告知对方自己的初始序列号，并确认收到对方的初始序列号。")])]),_._v(" "),t("p",[_._v("TCP实现了可靠的数据传输，原因之一就是TCP报文段维护了序列号字段和确认序列号字段，通过这两个字段双方都可以知道在自己发出的数据中，有哪些是被对方确认接收的，这两个字段的值会在初始序列号上递增，如果是两次握手，只有发起方的初始序列号可以得到确认，而对方的初始序列好得不到确认。")]),_._v(" "),t("h3",{attrs:{id:"_3-为什么是三次握手-而不是四次握手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-为什么是三次握手-而不是四次握手"}},[_._v("#")]),_._v(" 3.为什么是三次握手，而不是四次握手？")]),_._v(" "),t("p",[_._v("因为三次握手，已经可以确认双方发送和接收能力都正常，双方都知道彼此已经准备好了，而且可以完成对双方初始序列号的确认，也就无需四次握手了。")]),_._v(" "),t("ul",[t("li",[_._v("第一次握手，服务端确认“自己收”，客户端“发报文”功能正常。")]),_._v(" "),t("li",[_._v("第二次握手，客户端确认“自己收，自己发送”，服务端“收，发”功能正常，客户端认为连接已建立。")]),_._v(" "),t("li",[_._v("第三次握手，服务端确认“自己收，自己发送”，客户端“收，发”功能正常，此时双方均建立连接，可以正常通信。")])]),_._v(" "),t("h3",{attrs:{id:"_4-什么是syn洪泛攻击-如何防范"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-什么是syn洪泛攻击-如何防范"}},[_._v("#")]),_._v(" 4.什么是SYN洪泛攻击？如何防范？")]),_._v(" "),t("p",[_._v("SYN洪泛攻击属于一种DOS攻击，它利用TCP协议缺陷，通过发送大量的半连接请求，耗费CPU和资源。")]),_._v(" "),t("p",[_._v("原理：")]),_._v(" "),t("ul",[t("li",[_._v("在三次握手过程中，服务器发送"),t("code",[_._v("[SYN/ACK]")]),_._v("包（第二个包）之后，收到客户端的"),t("code",[_._v("[ACK]")]),_._v("包（第三个包）之前的TCP连接称为半连接，此时服务器处于"),t("code",[_._v("SYN_RECV")]),_._v("（等待客户端响应）的状态。如果接收到客户端的"),t("code",[_._v("[ACK]")]),_._v("，则TCP连接成功，如果未收到，则不断重发请求直至成功。")]),_._v(" "),t("li",[_._v("SYN攻击的攻击者会在短时间伪造大量不存在的IP地址，向服务器不断发送"),t("code",[_._v("[SYN]")]),_._v("包，服务器回复"),t("code",[_._v("[SYN/ACK]")]),_._v("包，并等待客户端的确认。由于源地址是不存在的，所以服务器需要不断重发直至超时。")]),_._v(" "),t("li",[_._v("这些伪造的"),t("code",[_._v("[SYN]")]),_._v("包长时间占用未连接队列，影响了正常的SYN，导致目的系统运行缓慢，网络堵塞甚至系统瘫痪。")])]),_._v(" "),t("p",[_._v("检测：当在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。")]),_._v(" "),t("p",[_._v("防范：")]),_._v(" "),t("ul",[t("li",[_._v("通过防火墙，路由器等过滤网关进行防护。")]),_._v(" "),t("li",[_._v("通过加固TCP/IP协议栈防护，如增加最大半连接数，缩短超时时间。")]),_._v(" "),t("li",[_._v("SYN cookies技术。SYN cookies是对TCP服务器的三次握手做一些修改，专门用来防范SYN 洪泛的攻击的一种手段。")])]),_._v(" "),t("h3",{attrs:{id:"_5-三次握手连接阶段-最后一次ack包丢失-会发生什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-三次握手连接阶段-最后一次ack包丢失-会发生什么"}},[_._v("#")]),_._v(" 5.三次握手连接阶段，最后一次ACK包丢失，会发生什么？")]),_._v(" "),t("p",[_._v("服务端：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("第三次的ACK在网络中丢失，那么服务端该TCP连接状态为"),t("code",[_._v("SYN_RECV")]),_._v("，并且会根据TCP的超时重传机制，会等待3秒，6秒，12秒后重新发送SYN+ACK包，以便客户端重新发送ACK包。")])]),_._v(" "),t("li",[t("p",[_._v("如果重发指定次数后，仍然未收到客户端的ACK应答，那么一段时间后，服务端会自动关闭这个连接。")])])]),_._v(" "),t("p",[_._v("客户端：")]),_._v(" "),t("p",[_._v("客户端认为这个连接已经建立，如果客户端向服务端发送数据，服务端将以RST包（Reset，标记复位，用于异常的关闭连接）响应。此时，客户端知道第三次握手失败。")]),_._v(" "),t("h3",{attrs:{id:"_6-详细介绍一下tcp的四次挥手过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-详细介绍一下tcp的四次挥手过程"}},[_._v("#")]),_._v(" 6.详细介绍一下TCP的四次挥手过程？")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/zhangrenfeng/images/raw/master/img/20210915202659.png",alt:"1111"}})]),_._v(" "),t("ul",[t("li",[t("p",[_._v("第一次挥手：客户端向服务端发送连接释放报文（FIN=1，ACK=1），主动关闭连接，同时等待服务端的确认。")]),_._v(" "),t("ul",[t("li",[_._v("序列号 seq = u，即客户端上次发送的报文的最后一个字节的序号 + 1")]),_._v(" "),t("li",[_._v("确认号 ack = k, 即服务端上次发送的报文的最后一个字节的序号 + 1")])])]),_._v(" "),t("li",[t("p",[_._v("第二次挥手：服务端收到连接释放报文后，立即发出"),t("strong",[_._v("确认报文")]),_._v("（ACK=1），序列号 seq = k，确认号 ack = u + 1。")]),_._v(" "),t("p",[_._v("这时 TCP 连接处于半关闭状态，即客户端到服务端的连接已经释放了，但是服务端到客户端的连接还未释放。这表示客户端已经没有数据发送了，但是服务端可能还要给客户端发送数据。")])]),_._v(" "),t("li",[t("p",[_._v("第三次挥手：服务端向客户端发送连接释放报文（FIN=1，ACK=1），主动关闭连接，同时等待 A 的确认。")]),_._v(" "),t("ul",[t("li",[_._v("序列号 seq = w，即服务端上次发送的报文的最后一个字节的序号 + 1。")]),_._v(" "),t("li",[_._v("确认号 ack = u + 1，与第二次挥手相同，因为这段时间客户端没有发送数据")])])]),_._v(" "),t("li",[t("p",[_._v("第四次挥手：客户端收到服务端的连接释放报文后，立即发出"),t("strong",[_._v("确认报文")]),_._v("（ACK=1），序列号 seq = u + 1，确认号为 ack = w + 1。")]),_._v(" "),t("p",[_._v("此时，客户端就进入了 "),t("code",[_._v("TIME-WAIT")]),_._v(" 状态。注意此时客户端到 TCP 连接还没有释放，必须经过 2*MSL（最长报文段寿命）的时间后，才进入 "),t("code",[_._v("CLOSED")]),_._v(" 状态。而服务端只要收到客户端发出的确认，就立即进入 "),t("code",[_._v("CLOSED")]),_._v(" 状态。可以看到，服务端结束 TCP 连接的时间要比客户端早一些。")])])]),_._v(" "),t("h3",{attrs:{id:"_7-为什么连接的时候是三次握手-关闭的时候却是四次握手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-为什么连接的时候是三次握手-关闭的时候却是四次握手"}},[_._v("#")]),_._v(" 7. 为什么连接的时候是三次握手，关闭的时候却是四次握手？")]),_._v(" "),t("p",[_._v("服务器在收到客户端的 FIN 报文段后，可能还有一些数据要传输，所以不能马上关闭连接，但是会做出应答，返回 ACK 报文段.")]),_._v(" "),t("p",[_._v("接下来可能会继续发送数据，在数据发送完后，服务器会向客户单发送 FIN 报文，表示数据已经发送完毕，请求关闭连接。服务器的"),t("strong",[_._v("ACK和FIN一般都会分开发送")]),_._v("，从而导致多了一次，因此一共需要四次挥手。")]),_._v(" "),t("h3",{attrs:{id:"_8-为什么客户端的-time-wait-状态必须等待-2msl"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-为什么客户端的-time-wait-状态必须等待-2msl"}},[_._v("#")]),_._v(" 8. 为什么客户端的 TIME-WAIT 状态必须等待 2MSL ？")]),_._v(" "),t("p",[_._v("主要有两个原因：")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("确保 ACK 报文能够到达服务端，从而使服务端正常关闭连接。")]),_._v(" "),t("p",[_._v("第四次挥手时，客户端第四次挥手的 ACK 报文不一定会到达服务端。服务端会超时重传 FIN/ACK 报文，此时如果客户端已经断开了连接，那么就无法响应服务端的二次请求，这样服务端迟迟收不到 FIN/ACK 报文的确认，就无法正常断开连接。")]),_._v(" "),t("p",[_._v("MSL 是报文段在网络上存活的最长时间。客户端等待 2MSL 时间，即「客户端 ACK 报文 1MSL 超时 + 服务端 FIN 报文 1MSL 传输」，就能够收到服务端重传的 FIN/ACK 报文，然后客户端重传一次 ACK 报文，并重新启动 2MSL 计时器。如此保证服务端能够正常关闭。")]),_._v(" "),t("p",[_._v("如果服务端重发的 FIN 没有成功地在 2MSL 时间里传给客户端，服务端则会继续超时重试直到断开连接。")])]),_._v(" "),t("li",[t("p",[_._v("防止已失效的连接请求报文段出现在之后的连接中。")])])]),_._v(" "),t("p",[_._v("TCP 要求在 2MSL 内不使用相同的序列号。客户端在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以保证本连接持续的时间内产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。或者即使收到这些过时的报文，也可以不处理它。")]),_._v(" "),t("h3",{attrs:{id:"_9-如果已经建立了连接-但是客户端出现故障了怎么办"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-如果已经建立了连接-但是客户端出现故障了怎么办"}},[_._v("#")]),_._v(" 9. 如果已经建立了连接，但是客户端出现故障了怎么办？")]),_._v(" "),t("p",[_._v("或者说，如果三次握手阶段、四次挥手阶段的包丢失了怎么办？如“服务端重发 FIN丢失”的问题。")]),_._v(" "),t("p",[_._v("简而言之，通过"),t("strong",[_._v("定时器 + 超时重试机制")]),_._v("，尝试获取确认，直到最后会自动断开连接。")]),_._v(" "),t("p",[_._v("具体而言，TCP 设有一个保活计时器。服务器每收到一次客户端的数据，都会重新复位这个计时器，时间通常是设置为 2 小时。若 2 小时还没有收到客户端的任何数据，服务器就开始重试：每隔 75 分钟发送一个探测报文段，若一连发送 10 个探测报文后客户端依然没有回应，那么服务器就认为连接已经断开了。")]),_._v(" "),t("h3",{attrs:{id:"_10-time-wait-状态过多会产生什么后果-怎样处理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-time-wait-状态过多会产生什么后果-怎样处理"}},[_._v("#")]),_._v(" 10. TIME-WAIT 状态过多会产生什么后果？怎样处理？")]),_._v(" "),t("p",[_._v("从服务器来讲，短时间内关闭了大量的Client连接，就会造成服务器上出现大量的TIME_WAIT连接，严重消耗着服务器的资源，此时部分客户端就会显示连接不上。")]),_._v(" "),t("p",[_._v("从客户端来讲，客户端TIME_WAIT过多，就会导致端口资源被占用，因为端口就65536个，被占满就会导致无法创建新的连接。")]),_._v(" "),t("p",[t("strong",[_._v("解决办法：")])]),_._v(" "),t("ul",[t("li",[t("p",[_._v("服务器可以设置 SO_REUSEADDR 套接字选项来避免 TIME_WAIT状态，此套接字选项告诉内核，即使此端口正忙（处于\nTIME_WAIT状态），也请继续并重用它。")])]),_._v(" "),t("li",[t("p",[_._v("调整系统内核参数，修改/etc/sysctl.conf文件，即修改"),t("code",[_._v("net.ipv4.tcp_tw_reuse 和 tcp_timestamps")])]),_._v(" "),t("div",{staticClass:"language-bash line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[_._v("net.ipv4.tcp_tw_reuse "),t("span",{pre:!0,attrs:{class:"token operator"}},[_._v("=")]),_._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[_._v("1")]),_._v(" 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；\nnet.ipv4.tcp_tw_recycle "),t("span",{pre:!0,attrs:{class:"token operator"}},[_._v("=")]),_._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[_._v("1")]),_._v(" 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。\n")])]),_._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[_._v("1")]),t("br"),t("span",{staticClass:"line-number"},[_._v("2")]),t("br")])])]),_._v(" "),t("li",[t("p",[_._v("强制关闭，发送 RST 包越过TIME_WAIT状态，直接进入CLOSED状态。")])])]),_._v(" "),t("h3",{attrs:{id:"_11-time-wait-是服务器端的状态-还是客户端的状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11-time-wait-是服务器端的状态-还是客户端的状态"}},[_._v("#")]),_._v(" 11. TIME_WAIT 是服务器端的状态?还是客户端的状态?")]),_._v(" "),t("p",[_._v("TIME_WAIT 是主动断开连接的一方会进入的状态，一般情况下，都是客户端所处的状态;服务器端一般设置不主动关闭连接。")]),_._v(" "),t("p",[_._v("TIME_WAIT 需要等待 2MSL，在大量短连接的情况下，TIME_WAIT会太多，这也会消耗很多系统资源。对于服务器来说，在 HTTP 协议里指定 KeepAlive（浏览器重用一个 TCP 连接来处理多个 HTTP 请求），由浏览器来主动断开连接，可以一定程度上减少服务器的这个问题。")]),_._v(" "),t("h3",{attrs:{id:"_12-tcp协议如何保证可靠性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-tcp协议如何保证可靠性"}},[_._v("#")]),_._v(" 12. TCP协议如何保证可靠性？")]),_._v(" "),t("p",[_._v("TCP主要提供了检验和、序列号/确认应答、超时重传、滑动窗口、拥塞控制和 流量控制等方法实现了可靠性传输。")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("检验和：通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃TCP段，重新发送。")])]),_._v(" "),t("li",[t("p",[_._v("序列号/确认应答：")]),_._v(" "),t("p",[_._v("序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。")]),_._v(" "),t("p",[_._v("TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文，这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。")])]),_._v(" "),t("li",[t("p",[_._v("滑动窗口：滑动窗口既提高了报文传输的效率，也避免了发送方发送过多的数据而导致接收方无法正常处理的异常。")])]),_._v(" "),t("li",[t("p",[_._v("超时重传：超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。最大超时时间是动态计算的。")])]),_._v(" "),t("li",[t("p",[_._v("拥塞控制：在数据传输过程中，可能由于网络状态的问题，造成网络拥堵，此时引入拥塞控制机制，在保证TCP可靠性的同时，提高性能。")])]),_._v(" "),t("li",[t("p",[_._v("流量控制：如果主机A 一直向主机B发送数据，不考虑主机B的接受能力，则可能导致主机B的接受缓冲区满了而无法再接受数据，从而会导致大量的数据丢包，引发重传机制。而在重传的过程中，若主机B的接收缓冲区情况仍未好转，则会将大量的时间浪费在重传数据上，降低传送数据的效率。所以引入流量控制机制，主机B通过告诉主机A自己接收缓冲区的大小，来使主机A控制发送的数据量。流量控制与TCP协议报头中的窗口大小有关。")])])]),_._v(" "),t("h3",{attrs:{id:"_13-详细讲一下tcp的滑动窗口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-详细讲一下tcp的滑动窗口"}},[_._v("#")]),_._v(" 13. 详细讲一下TCP的滑动窗口？")]),_._v(" "),t("p",[_._v("在进行数据传输时，如果传输的数据比较大，就需要拆分为多个数据包进行发送。TCP 协议需要对数据进行确认后，才可以发送下一个数据包。这样一来，就会在等待确认应答包环节浪费时间。")]),_._v(" "),t("p",[_._v("为了避免这种情况，TCP引入了窗口概念。窗口大小指的是不需要等待确认应答包而可以继续发送数据包的最大值。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/zhangrenfeng/images/raw/master/img/20210915204909.png",alt:"11"}})]),_._v(" "),t("p",[_._v("从上面的图可以看到滑动窗口左边的是已发送并且被确认的分组，滑动窗口右边是还没有轮到的分组。")]),_._v(" "),t("p",[_._v("滑动窗口里面也分为两块，一块是已经发送但是未被确认的分组，另一块是窗口内等待发送的分组。随着已发送的分组不断被确认，窗口内等待发送的分组也会不断被发送。整个窗口就会往右移动，让还没轮到的分组进入窗口内。")]),_._v(" "),t("p",[_._v("可以看到滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前 TCP 发送包的速率，而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。")]),_._v(" "),t("h3",{attrs:{id:"_14-详细讲一下拥塞控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-详细讲一下拥塞控制"}},[_._v("#")]),_._v(" 14. 详细讲一下拥塞控制？")]),_._v(" "),t("p",[_._v("TCP 一共使用了四种算法来实现拥塞控制：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("慢开始 (slow-start)；")])]),_._v(" "),t("li",[t("p",[_._v("拥塞避免 (congestion avoidance)；")])]),_._v(" "),t("li",[t("p",[_._v("快速重传 (fast retransmit)；")])]),_._v(" "),t("li",[t("p",[_._v("快速恢复 (fast recovery)。")])])]),_._v(" "),t("p",[_._v("发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。当cwndssthresh时，改用拥塞避免算法。")]),_._v(" "),t("p",[_._v("**慢开始：**不要一开始就发送大量的数据，由小到大逐渐增加拥塞窗口的大小。")]),_._v(" "),t("p",[_._v("**拥塞避免：**拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1而不是加倍。这样拥塞窗口按线性规律缓慢增长。")]),_._v(" "),t("p",[t("strong",[_._v("快重传："),t("strong",[_._v("我们可以剔除一些不必要的拥塞报文，提高网络吞吐量。比如接收方在")]),_._v("收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时捎带确认。"),t("strong",[_._v("快重传规定：发送方只要")]),_._v("一连收到三个")]),_._v("重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/zhangrenfeng/images/raw/master/img/20210915204934.png",alt:"12"}})]),_._v(" "),t("p",[t("strong",[_._v("快恢复："),t("strong",[_._v("主要是配合快重传。当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半（为了预防网络发生拥塞），但")]),_._v("接下来并不执行慢开始算法")]),_._v("，因为如果网络出现拥塞的话就不会收到好几个重复的确认，收到三个重复确认说明网络状况还可以。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/zhangrenfeng/images/raw/master/img/20210915204956.png",alt:"13"}})])])}),[],!1,null,null,null);v.default=s.exports}}]);