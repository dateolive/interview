(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{451:function(s,t,a){"use strict";a.r(t);var n=a(27),e=Object(n.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现原理"}},[s._v("#")]),s._v(" 实现原理")]),s._v(" "),a("h3",{attrs:{id:"_1-concurrenthashmap的实现原理是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-concurrenthashmap的实现原理是什么"}},[s._v("#")]),s._v(" 1.ConcurrentHashMap的实现原理是什么？")]),s._v(" "),a("p",[s._v("在JDK1.7中，ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成的，和hashmap一样，是数组+链表组成的。ConcurrentHashMap把哈希桶数组分成一个个小数组Segment，每个小数组有n个HashEntry组成。")]),s._v(" "),a("p",[s._v("首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一段数据时，其他段的数据也能被其他线程访问，实现了真正的并发访问。")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/zhangrenfeng/images/raw/master/img/20210911112228.png",alt:"11"}})]),s._v(" "),a("p",[s._v("Segment是ConcurrentHashMap的内部类，组成如下：")]),s._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("static")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("final")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Segment")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("K")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("V")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("extends")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("ReentrantLock")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("implements")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Serializable")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n       "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("private")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("static")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("final")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("long")]),s._v(" serialVersionUID "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2249069246763182397L")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n       \n       "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 和 HashMap 中的 HashEntry 作用一样，真正存放数据的桶")]),s._v("\n       "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("transient")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("volatile")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("HashEntry")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("K")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("V")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" table"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n       "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("transient")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" count"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n       "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("transient")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" modCount"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n       "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("transient")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" threshold"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n       "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("final")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("float")]),s._v(" loadFactor"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n       \n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br")])]),a("p",[s._v("Segment 继承了 ReentrantLock，所以 Segment 是一种可重入锁，扮演锁的角色。Segment 默认为 16，也就是并发度为 16。")]),s._v(" "),a("p",[s._v("存放元素的 HashEntry，也是一个静态内部类，组成如下：")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/zhangrenfeng/images/raw/master/img/20210911114256.png",alt:"12"}})]),s._v(" "),a("p",[s._v("和 HashMap 非常类似，唯一的区别就是其中的核心数据如 value ，以及链表都是 volatile 修饰的，保证了多线程下获取时的可见性。")]),s._v(" "),a("p",[s._v("原理上来说：ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。")]),s._v(" "),a("p",[s._v("在JDK1.8中，ConcurrentHashMap是由数组+链表+红黑树结构。在锁的实现上，抛弃了原先的Segment分段锁，采用了CAS+Synchronized实现了更加细粒度的锁。")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/zhangrenfeng/images/raw/master/img/20210911130534.png",alt:"123"}})]),s._v(" "),a("blockquote",[a("p",[s._v("JDK1.8 中为什么使用内置锁 synchronized替换 可重入锁 ReentrantLock？")])]),s._v(" "),a("ul",[a("li",[s._v("在JDK1.6中，对synchronized锁进行了优化，并且使用了synchronized有多种锁状态，会从无锁->偏向锁->轻量级锁->重量级锁一步步转化。")]),s._v(" "),a("li",[s._v("减少内存开销 。假设使用可重入锁来获得同步支持，那么每个节点都需要通过继承 AQS 来获得同步支持。但并不是每个节点都需要获得同步支持的，只有链表的头节点（红黑树的根节点）需要同步，这无疑带来了巨大内存浪费。")])]),s._v(" "),a("h3",{attrs:{id:"关于concurrenthashmap其他问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关于concurrenthashmap其他问题"}},[s._v("#")]),s._v(" 关于ConcurrentHashMap其他问题？")]),s._v(" "),a("p",[a("a",{attrs:{href:"https://dateolive.github.io/interview/pages/9fb2bc/#_18-concurrenthashmap%E7%9A%84put%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91",target:"_blank",rel:"noopener noreferrer"}},[s._v("https://dateolive.github.io/interview/pages/9fb2bc/#_18-concurrenthashmap的put执行逻辑"),a("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=e.exports}}]);