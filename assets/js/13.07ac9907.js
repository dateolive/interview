(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{455:function(_,v,t){"use strict";t.r(v);var a=t(27),r=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"jvm垃圾回收"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm垃圾回收"}},[_._v("#")]),_._v(" JVM垃圾回收")]),_._v(" "),t("h2",{attrs:{id:"jvm内存分配"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm内存分配"}},[_._v("#")]),_._v(" JVM内存分配")]),_._v(" "),t("p",[_._v("Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 "),t("strong",[_._v("堆")]),_._v(" 内存中对象的分配与回收。")]),_._v(" "),t("p",[_._v("Java堆是垃圾回收管理的主要区域，也被称为"),t("strong",[_._v("GC堆")]),_._v("，现在大多JVM的垃圾回收机制，采用的是分代垃圾收集算法。")]),_._v(" "),t("p",[_._v("Java堆可以被细分成新生代，老年代，元空间（JDK 1.8 之前是永久代）。新生代又可以细分成 伊甸园区（Eden），幸存者区。幸存者区可以划分为From Survivor和To Survivor 区。")]),_._v(" "),t("p",[_._v("划分成多个区的目的是更好地回收内存，分配内存。")]),_._v(" "),t("p",[_._v("堆空间的基本结构（图示）：")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/zhangrenfeng/images/raw/master/img/20210323135320.png",alt:"image-20210323135311211"}})]),_._v(" "),t("p",[_._v("大部分情况下，对象首先会在Eden区分配，在一次新生代GC后，如果对象还存活，就会进入幸存者区，且对象年龄会加1，当它年龄达到一定的阈值时，就会被晋升到老年代，对象晋升到老年代的年龄阈值，可以通过"),t("code",[_._v("-XX:MaxTenuringThreshold")]),_._v("来设置，默认值是15。")]),_._v(" "),t("p",[_._v("关于这个年龄阈值，JVM实现了动态年龄计算算法，Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累计，当累积的某个年龄大小超过survivor区的一半时，取这个值和MaxTenuringThreshold中更小的一个值，作为晋升的年龄阈值。")]),_._v(" "),t("p",[_._v('经过这次 GC 后，Eden 区和"From"区已经被清空。这个时候，"From"和"To"会交换他们的角色，也就是新的"To"就是上次 GC 前的“From”，新的"From"就是上次 GC 前的"To"。不管怎样，都会保证名为 To 的 Survivor 区域是空的。Minor GC 会一直重复这样的过程，直到“To”区被填满，"To"区被填满之后，会将所有对象移动到老年代中。')]),_._v(" "),t("h2",{attrs:{id:"对象已经死亡"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象已经死亡"}},[_._v("#")]),_._v(" 对象已经死亡？")]),_._v(" "),t("p",[_._v("在进行垃圾回收机制前，需要判断哪些对象已经死亡")]),_._v(" "),t("h3",{attrs:{id:"_1-引用计数算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-引用计数算法"}},[_._v("#")]),_._v(" 1. 引用计数算法")]),_._v(" "),t("p",[_._v("给对象添加一个引用计数器，每当有一个地方引用时，计数器+1，引用失效时；计数器-1；任何时候计数器为0的对象就是不可能再被使用的。")]),_._v(" "),t("p",[_._v("优点：简单，效率高")]),_._v(" "),t("p",[_._v("缺点：难以解决对象之间相互循环引用问题")]),_._v(" "),t("p",[_._v("比如a引用b，b引用a，a=null且b=null，但他们的引用计数器都不为0，所以GC无法回收他们")]),_._v(" "),t("h3",{attrs:{id:"_2-可达性分析算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-可达性分析算法"}},[_._v("#")]),_._v(" 2. 可达性分析算法")]),_._v(" "),t("p",[_._v("以“"),t("strong",[_._v("GC Roots")]),_._v("”为根节点向下搜索，节点走过的路径称为引用链，当一个对象到"),t("strong",[_._v("GC Roots")]),_._v("没有任何引用链相连的话，则说明这个对象是不可用的。")]),_._v(" "),t("p",[_._v("可作为"),t("strong",[_._v("GC Roots")]),_._v("的对象有：")]),_._v(" "),t("ul",[t("li",[_._v("虚拟机栈（栈帧中的本地变量表）中的引用对象")]),_._v(" "),t("li",[_._v("本地方法栈中引用的对象")]),_._v(" "),t("li",[_._v("方法区中类静态属性引用的对象")]),_._v(" "),t("li",[_._v("方法区中常量引用的对象")]),_._v(" "),t("li",[_._v("所有被同步锁持有的对象")])]),_._v(" "),t("p",[t("strong",[_._v("不可达的对象并非“非死不可”")])]),_._v(" "),t("p",[_._v("即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。")]),_._v(" "),t("p",[_._v("被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。")]),_._v(" "),t("h4",{attrs:{id:"_3-理解四种引用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-理解四种引用"}},[_._v("#")]),_._v(" 3. 理解四种引用")]),_._v(" "),t("p",[t("strong",[_._v("3.1．强引用（StrongReference）")])]),_._v(" "),t("p",[_._v("以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于"),t("strong",[_._v("必不可少的生活用品")]),_._v("，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。")]),_._v(" "),t("p",[t("strong",[_._v("3.2．软引用（SoftReference）")])]),_._v(" "),t("p",[_._v("如果一个对象只具有软引用，那就类似于"),t("strong",[_._v("可有可无的生活用品")]),_._v("。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。")]),_._v(" "),t("p",[_._v("软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。")]),_._v(" "),t("p",[t("strong",[_._v("3.3．弱引用（WeakReference）")])]),_._v(" "),t("p",[_._v("如果一个对象只具有弱引用，那就类似于"),t("strong",[_._v("可有可无的生活用品")]),_._v("。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。")]),_._v(" "),t("p",[_._v("弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。")]),_._v(" "),t("p",[t("strong",[_._v("3.4．虚引用（PhantomReference）")])]),_._v(" "),t("p",[_._v('"虚引用"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。')]),_._v(" "),t("p",[t("strong",[_._v("虚引用主要用来跟踪对象被垃圾回收的活动")]),_._v("。")]),_._v(" "),t("p",[t("strong",[_._v("虚引用与软引用和弱引用的一个区别在于：")]),_._v(" 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。")]),_._v(" "),t("p",[_._v("特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为"),t("strong",[_._v("软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生")]),_._v("。")]),_._v(" "),t("h4",{attrs:{id:"_4-常量是否是废弃常量和类是否是无用类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-常量是否是废弃常量和类是否是无用类"}},[_._v("#")]),_._v(" 4. 常量是否是废弃常量和类是否是无用类")]),_._v(" "),t("p",[t("strong",[_._v("废弃常量判断方法：")])]),_._v(" "),t("blockquote",[t("ol",[t("li",[t("strong",[_._v("JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代")])]),_._v(" "),t("li",[t("strong",[_._v("JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代")]),_._v(" 。")]),_._v(" "),t("li",[t("strong",[_._v("JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)")])])])]),_._v(" "),t("p",[_._v('如果字符串常量池中存在字符串"adb"，如果当前没有任何String对象引用该字符串的话，说明当前常量就是废弃常量，如果这时发生GC且有必要的话，这个废弃常量就会被清理掉。')]),_._v(" "),t("p",[t("strong",[_._v("无用类判断条件：")])]),_._v(" "),t("ul",[t("li",[_._v("该类所有实例都被回收，Java堆中不存在该类的任何实例")]),_._v(" "),t("li",[_._v("加载该类的"),t("code",[_._v("ClassLoader")]),_._v("已被回收")]),_._v(" "),t("li",[_._v("该类对应的"),t("code",[_._v("java.lang.Class")]),_._v("对象没有再任何地方被引用，无法在任何地方通过反射访问该类")])]),_._v(" "),t("p",[_._v("满足上面三个条件，无用类才可能会被回收")]),_._v(" "),t("h2",{attrs:{id:"垃圾收集算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集算法"}},[_._v("#")]),_._v(" 垃圾收集算法")]),_._v(" "),t("h3",{attrs:{id:"_1-标记-清除算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-标记-清除算法"}},[_._v("#")]),_._v(" 1.标记-清除算法")]),_._v(" "),t("p",[_._v("首先遍历所有对象，对不需要回收的对象进行标记，在标记完后统一回收所有没被标记的对象。")]),_._v(" "),t("ul",[t("li",[_._v("优点:不需要额外的空间")]),_._v(" "),t("li",[_._v("缺点:两次扫描,严重浪费时间,会产生内存碎片")])]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/zhangrenfeng/images/raw/master/img/20210323152028.png",alt:"image-20210323152027353"}})]),_._v(" "),t("h3",{attrs:{id:"_2-标记-复制算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-标记-复制算法"}},[_._v("#")]),_._v(" 2.标记-复制算法")]),_._v(" "),t("p",[_._v("将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。")]),_._v(" "),t("ul",[t("li",[_._v("好处:没有内存的碎片")]),_._v(" "),t("li",[_._v("坏处:浪费了内存空间:多了一半空间永远是空 to.假设对象100%存活(极端情况)")]),_._v(" "),t("li",[t("strong",[_._v("复制算法最佳使用场景")]),_._v(":对象存活度较低的时候:新生区")])]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/zhangrenfeng/images/raw/master/img/20210323151511.png",alt:"image-20210323151510695"}})]),_._v(" "),t("h4",{attrs:{id:""}},[t("a",{staticClass:"header-anchor",attrs:{href:"#"}},[_._v("#")])]),_._v(" "),t("h3",{attrs:{id:"_3-标记-压缩-整理-算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-标记-压缩-整理-算法"}},[_._v("#")]),_._v(" 3. 标记-压缩（整理）算法")]),_._v(" "),t("p",[_._v("标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/zhangrenfeng/images/raw/master/img/20210323152523.png",alt:"image-20210323152521402"}})]),_._v(" "),t("p",[t("em",[t("strong",[_._v("三种垃圾收集算法的比较：")])])]),_._v(" "),t("ul",[t("li",[t("p",[_._v("内存效率（时间复杂度）：标记-复制算法 > 标记-清除算法 > 标记-压缩算法")])]),_._v(" "),t("li",[t("p",[_._v("内存整齐度：标记-复制算法 > 标记-压缩算法 > 标记-清除算法")])]),_._v(" "),t("li",[t("p",[_._v("内存利用率：标记-压缩算法 > 标记-清除算法 > 标记-复制算法")])])]),_._v(" "),t("h3",{attrs:{id:"_4-分代收集算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-分代收集算法"}},[_._v("#")]),_._v(" 4. 分代收集算法")]),_._v(" "),t("p",[_._v("对堆中各个年代的特点选择合适的垃圾收集算法，称为分代收集算法。")]),_._v(" "),t("p",[_._v("根据新生代中对象存活率低的特点，可以选择标记-复制算法，老年代中对象存活率高，而且没有额外的空间对它进行分配担保，可以选择标记-清除算法和标记-压缩算法混合实现。")]),_._v(" "),t("h2",{attrs:{id:"垃圾收集器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集器"}},[_._v("#")]),_._v(" 垃圾收集器")]),_._v(" "),t("blockquote",[t("p",[_._v("垃圾回收器是内存回收的具体实现，没有最好的垃圾收集器，只有最适合的垃圾收集器。")])]),_._v(" "),t("p",[_._v("这里主要记录下四种常见的垃圾收集器")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("串行垃圾收集器")])]),_._v(" "),t("li",[t("p",[_._v("并行垃圾收集器")])]),_._v(" "),t("li",[t("p",[_._v("CMS垃圾收集器")])]),_._v(" "),t("li",[t("p",[_._v("G1垃圾收集器")])])]),_._v(" "),t("h4",{attrs:{id:"_1-serial-串行收集器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-serial-串行收集器"}},[_._v("#")]),_._v(" 1. Serial 串行收集器")]),_._v(" "),t("p",[_._v("Serial串行收集器是最基本，历史最悠久的垃圾收集器，是一个单线程的收集器。")]),_._v(" "),t("p",[_._v("它的 "),t("strong",[_._v("“单线程”")]),_._v(" 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ "),t("strong",[_._v('"Stop The World"')]),_._v(" ），直到它收集结束。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/zhangrenfeng/images/raw/master/img/20210323153920.png",alt:"image-20210323153919053"}})]),_._v(" "),t("p",[t("strong",[_._v("Serial串行收集器")])]),_._v(" "),t("ul",[t("li",[t("p",[_._v("优点：简单高效")])]),_._v(" "),t("li",[t("p",[_._v("缺点：工作时需要暂停其他的工作线程")])])]),_._v(" "),t("h3",{attrs:{id:"_2-parnew-并行收集器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-parnew-并行收集器"}},[_._v("#")]),_._v(" 2. ParNew 并行收集器")]),_._v(" "),t("p",[_._v("ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/zhangrenfeng/images/raw/master/img/20210323154324.png",alt:"image-20210323154322431"}})]),_._v(" "),t("p",[_._v("相较于串行收集器，并行收集器的优点就是，多个线程进行垃圾收集")]),_._v(" "),t("h3",{attrs:{id:"_3-cms-收集器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-cms-收集器"}},[_._v("#")]),_._v(" 3. CMS 收集器")]),_._v(" "),t("p",[t("strong",[_._v("CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。")])]),_._v(" "),t("p",[t("strong",[_._v("CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。")])]),_._v(" "),t("p",[_._v("从名字中的"),t("strong",[_._v("Mark Sweep")]),_._v("这两个词可以看出，CMS 收集器是一种 "),t("strong",[_._v("“标记-清除”算法")]),_._v("实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("初始标记：")]),_._v(" 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；")]),_._v(" "),t("li",[t("strong",[_._v("并发标记：")]),_._v(" 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。")]),_._v(" "),t("li",[t("strong",[_._v("重新标记：")]),_._v(" 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短")]),_._v(" "),t("li",[t("strong",[_._v("并发清除：")]),_._v(" 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。")])]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/zhangrenfeng/images/raw/master/img/20210323154639.png",alt:"image-20210323154637667"}})]),_._v(" "),t("h3",{attrs:{id:"_4-g1-收集器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-g1-收集器"}},[_._v("#")]),_._v(" 4.G1 收集器")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://gitee.com/zhangrenfeng/images/raw/master/img/20210323154801.png",alt:"image-20210323154800284"}})])])}),[],!1,null,null,null);v.default=r.exports}}]);